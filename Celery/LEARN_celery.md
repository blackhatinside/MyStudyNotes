## CELERY:
Segregation and temporary holding is done by message queue, a part of the message broker; and exchanges in message broker use binding rules for segregation of tasks into different storage queues. Task queues are basically { message queues + execution logic, scheduling and management }

User/Client/Consumer sends the task to the application in the form of message (message passing) and the celery based app then enqueues the task into the Message broker (Redis which is FIFO based) and then the celery worker machines which are listening to this celery queue take up the task on arrival into the queue and then try to process these tasks by spawning child processes or threads (concept of execution pool) and finally send back the result to a backend result queue which is later on used by the user or client. And also if the user wishes to know the progress of the task he can make use of client API to check task completion status through web sockets. And also CPU intensive tasks are done by preforks and I/O intensive tasks are done by threads and solo doesnt spawn any sub processes and instead tries to do the task by itself hence it is faster than prefork and thread pool. Concurrency level should be less than or equal to the number of CPU cores for true parallelism.

so basically the exchange, binding rules, different queues are all part of message broker and the tasks are sent to appropriate queues for the workers to process them.
